import 'dart:async';
import 'dart:convert';
import 'dart:developer';
import 'dart:ui';

import 'package:flutter/material.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import 'package:geolocator/geolocator.dart';
import 'package:http/http.dart' as http;
import 'package:Safe_pulse/Api/ApiService.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:stomp_dart_client/stomp_dart_client.dart';

Future<void> initializeService() async {
  final service = FlutterBackgroundService();
  await service.configure(
    androidConfiguration: AndroidConfiguration(
      onStart: onStart,
      autoStart: true,
      isForegroundMode: false,
      autoStartOnBoot: true,
      notificationChannelId: 'location_service',
      initialNotificationTitle: 'Location Tracking',
      initialNotificationContent: 'Running in background',
    ),
    iosConfiguration: IosConfiguration(
      autoStart: true,
      onForeground: onStart,
      onBackground: onIosBackground,
    ),
  );
}

@pragma('vm:entry-point')
Future<bool> onIosBackground(ServiceInstance service) async {
  WidgetsFlutterBinding.ensureInitialized();
  DartPluginRegistrant.ensureInitialized();
  return true;
}

@pragma('vm:entry-point')
void onStart(ServiceInstance service) async {
  DartPluginRegistrant.ensureInitialized();

  // Initialize WebSocket client
  StompClient? stompClient;
  String? userEmail;
  String? userId;
  bool isWebSocketConnected = false;
  final List<Map<String, dynamic>> pendingLocations = [];
  StreamSubscription<Position>? positionStream;

  // Get user data from SharedPreferences
  getuserData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      userEmail = prefs.getString("username");
      userId = prefs.getString("userId");
    } catch (e) {
      log("Error getting user data: $e");
    }
  }

  await getuserData();

  // Function to send pending locations via API
  Future<void> sendPendingLocations() async {
    if (pendingLocations.isEmpty || userEmail == null) return;

    try {
      final url = Uri.parse(
          '${ApiService.baseUrl}/api/rest/bulk-location-save?username=$userEmail');
      final headers = {'Content-Type': 'application/json'};
      final body = jsonEncode(pendingLocations);

      final response = await http.post(url, headers: headers, body: body);

      if (response.statusCode == 200) {
        log("Successfully sent ${pendingLocations.length} pending locations");
        pendingLocations.clear();
        final prefs = await SharedPreferences.getInstance();
        await prefs.remove('pending_locations');
      } else {
        log("Failed to send pending locations: ${response.statusCode}");
      }
    } catch (e) {
      log("Error sending pending locations: $e");
    }
  }

  // Load pending locations from storage
  Future<void> loadPendingLocations() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final pending = prefs.getString('pending_locations');
      if (pending != null) {
        final List<dynamic> decoded = jsonDecode(pending);
        pendingLocations.addAll(decoded.cast<Map<String, dynamic>>());
        log("Loaded ${pendingLocations.length} pending locations from storage");
      }
    } catch (e) {
      log("Error loading pending locations: $e");
    }
  }

  // Save pending locations to storage
  Future<void> savePendingLocations() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('pending_locations', jsonEncode(pendingLocations));
      log("Saved ${pendingLocations.length} pending locations to storage");
    } catch (e) {
      log("Error saving pending locations: $e");
    }
  }

  // Setup WebSocket connection
  void connectWebSocket() {
    stompClient = StompClient(
      config: StompConfig.sockJS(
        url: '${ApiService.baseUrl}//ws-location',
        onConnect: (StompFrame frame) {
          log("WebSocket connected");
          isWebSocketConnected = true;
          sendPendingLocations();
        },
        onDisconnect: (frame) {
          log("WebSocket disconnected");
          isWebSocketConnected = false;
        },
        onWebSocketError: (dynamic error) {
          log("WebSocket error: $error");
          isWebSocketConnected = false;
        },
        reconnectDelay: const Duration(seconds: 5),
      ),
    );
    stompClient?.activate();
  }

  // Load any pending locations at startup
  await loadPendingLocations();

  // Connect to WebSocket
  connectWebSocket();

  if (service is AndroidServiceInstance) {
    service.setAsForegroundService();
    service.on('setAsForeground').listen((event) {
      service.setAsForegroundService();
    });
    service.on('setAsBackground').listen((event) {
      service.setAsBackgroundService();
    });
  }

  service.on('stopService').listen((event) {
    positionStream?.cancel();
    stompClient?.deactivate();
    service.stopSelf();
  });

  // Start listening to position updates
  void startPositionUpdates() async {
    if (await Permission.locationAlways.isDenied) {
      log("Location permission denied");
      if (service is AndroidServiceInstance) {
        if (await service.isForegroundService()) {
          await service.setForegroundNotificationInfo(
            title: "Permission Denied",
            content: "Waiting for location permission",
          );
        }
      }
      return;
    }

    positionStream = Geolocator.getPositionStream(
      locationSettings: const LocationSettings(
        accuracy: LocationAccuracy.high,
        distanceFilter: 10, // Minimum distance in meters to trigger updates
      ),
    ).listen((Position position) async {
      if (service is AndroidServiceInstance) {
        if (await service.isForegroundService()) {
          await service.setForegroundNotificationInfo(
            title: "Your location",
            content: "${position.latitude},${position.longitude}",
          );
        }
      }

      log("Location changed: ${position.latitude},${position.longitude}");
      service.invoke('update');

      // Prepare location data
      final location = {
        'latitude': position.latitude,
        'longitude': position.longitude,
        'timestamp': DateTime.now().toIso8601String(),
        'userId': userId,
      };

      // Try to send via WebSocket if connected
      if (isWebSocketConnected && userId != null && userEmail != null) {
        try {
          stompClient?.send(
            destination: '/app/update-location',
            body: jsonEncode(location),
          );
          log("Location data sent via WebSocket: $userId,${position.latitude}");
        } catch (e) {
          log("WebSocket send error, storing locally: $e");
          pendingLocations.add(location);
          await savePendingLocations();
          if (!isWebSocketConnected) {
            connectWebSocket();
          }
        }
      } else {
        log("WebSocket not connected or user data missing - storing locally");
        pendingLocations.add(location);
        await savePendingLocations();
      }
    }, onError: (e) {
      log("Position stream error: $e");
    });
  }

  // Start the position updates
  startPositionUpdates();
}
