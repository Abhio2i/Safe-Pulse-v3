import 'dart:async';
import 'dart:convert';
import 'dart:developer';
import 'dart:ui';

import 'package:flutter/material.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import 'package:geolocator/geolocator.dart';
import 'package:http/http.dart' as http;
import 'package:Safe_pulse/Api/ApiService.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:stomp_dart_client/stomp_dart_client.dart';

Future<void> initializeService() async {
  final service = FlutterBackgroundService();
  await service.configure(
    androidConfiguration: AndroidConfiguration(
      onStart: onStart,
      autoStart: true,
      isForegroundMode: true,
      autoStartOnBoot: true,
      notificationChannelId: 'location_service',
      initialNotificationTitle: 'Location Tracking',
      initialNotificationContent: 'Running in background',
    ),
    iosConfiguration: IosConfiguration(
      autoStart: true,
      onForeground: onStart,
      onBackground: onIosBackground,
    ),
  );
}

@pragma('vm:entry-point')
Future<bool> onIosBackground(ServiceInstance service) async {
  //log('Service is running in the background');
  WidgetsFlutterBinding.ensureInitialized();
  DartPluginRegistrant.ensureInitialized();
  return true;
}

@pragma('vm:entry-point')
void onStart(ServiceInstance service) async {
  //log('Service started');
  DartPluginRegistrant.ensureInitialized();

  // Initialize WebSocket client
  StompClient? stompClient;
  String? userEmail;
  String? userId;
  bool isWebSocketConnected = false;
  final List<Map<String, dynamic>> pendingLocations = [];

  // Variables to track last saved location and time (for both sent and pending)
  Position? lastSavedPosition;
  DateTime? lastSavedTime;

  // Get user data from SharedPreferences
  try {
    final prefs = await SharedPreferences.getInstance();
    userEmail = prefs.getString("username");
    userId = prefs.getString("userId");

    // Load last saved position and time
    final lastSavedPosStr = prefs.getString('last_saved_position');
    final lastSavedTimeStr = prefs.getString('last_saved_time');

    if (lastSavedPosStr != null) {
      final posData = jsonDecode(lastSavedPosStr);
      lastSavedPosition = Position(
        latitude: posData['latitude'],
        longitude: posData['longitude'],
        altitudeAccuracy: 0,
        headingAccuracy: 0,
        timestamp: DateTime.now(),
        accuracy: 0,
        altitude: 0,
        heading: 0,
        speed: 0,
        speedAccuracy: 0,
      );
    }

    if (lastSavedTimeStr != null) {
      lastSavedTime = DateTime.parse(lastSavedTimeStr);
    }
  } catch (e) {
    //log("Error getting user data: $e");
  }

  // Function to send pending locations via API
  Future<void> sendPendingLocations() async {
    if (pendingLocations.isEmpty || userEmail == null) return;

    try {
      final url = Uri.parse(
          '${ApiService.baseUrl}/api/rest/bulk-location-save?username=$userEmail');
      final headers = {'Content-Type': 'application/json'};
      final body = jsonEncode(pendingLocations);

      final response = await http.post(url, headers: headers, body: body);

      if (response.statusCode == 200) {
        //log("Successfully sent ${pendingLocations.length} pending locations");
        pendingLocations.clear();
        final prefs = await SharedPreferences.getInstance();
        await prefs.remove('pending_locations');
      } else {
        //log("Failed to send pending locations: ${response.statusCode}");
      }
    } catch (e) {
      //log("Error sending pending locations: $e");
    }
  }

  // Load pending locations from storage
  Future<void> loadPendingLocations() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final pending = prefs.getString('pending_locations');
      if (pending != null) {
        final List<dynamic> decoded = jsonDecode(pending);
        pendingLocations.addAll(decoded.cast<Map<String, dynamic>>());
        //log("Loaded ${pendingLocations.length} pending locations from storage");

        // Update last saved position from the most recent pending location
        if (pendingLocations.isNotEmpty) {
          final lastPending = pendingLocations.last;
          lastSavedPosition = Position(
            latitude: lastPending['latitude'],
            longitude: lastPending['longitude'],
            altitudeAccuracy: 0,
            headingAccuracy: 0,
            timestamp: DateTime.now(),
            accuracy: 0,
            altitude: 0,
            heading: 0,
            speed: 0,
            speedAccuracy: 0,
          );
          lastSavedTime = DateTime.parse(lastPending['timestamp']);
        }
      }
    } catch (e) {
      //log("Error loading pending locations: $e");
    }
  }

  // Save pending locations to storage
  Future<void> savePendingLocations() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('pending_locations', jsonEncode(pendingLocations));
      //log("Saved ${pendingLocations.length} pending locations to storage");
    } catch (e) {
      //log("Error saving pending locations: $e");
    }
  }

  // Save last saved position and time
  Future<void> saveLastSavedData(Position position) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(
          'last_saved_position',
          jsonEncode({
            'latitude': position.latitude,
            'longitude': position.longitude,
          }));
      await prefs.setString(
          'last_saved_time', DateTime.now().toIso8601String());
    } catch (e) {
      //log("Error saving last saved data: $e");
    }
  }

  // Check if we should save/send the new location
  bool shouldSaveLocation(Position newPosition) {
    // Always save if we don't have a previous location
    if (lastSavedPosition == null || lastSavedTime == null) {
      return true;
    }

    // Check if 5 minutes have passed since last save
    final fiveMinutesAgo = DateTime.now().subtract(const Duration(minutes: 5));
    if (lastSavedTime!.isBefore(fiveMinutesAgo)) {
      return true;
    }

    // Check if distance is more than 10 meters
    final distance = Geolocator.distanceBetween(
      lastSavedPosition!.latitude,
      lastSavedPosition!.longitude,
      newPosition.latitude,
      newPosition.longitude,
    );

    return distance > 10;
  }

  // Setup WebSocket connection
  void connectWebSocket() {
    stompClient = StompClient(
      config: StompConfig.sockJS(
        url: '${ApiService.baseUrl}//ws-location',
        onConnect: (StompFrame frame) {
          //log("WebSocket connected");
          isWebSocketConnected = true;
          // Try to send any pending locations when connection is restored
          sendPendingLocations();
        },
        onDisconnect: (frame) {
          //log("WebSocket disconnected");
          isWebSocketConnected = false;
        },
        onWebSocketError: (dynamic error) {
          //log("WebSocket error: $error");
          isWebSocketConnected = false;
        },
        reconnectDelay: const Duration(seconds: 5),
      ),
    );
    stompClient?.activate();
  }

  // Load any pending locations at startup
  await loadPendingLocations();

  // Connect to WebSocket
  connectWebSocket();

  if (service is AndroidServiceInstance) {
    service.setAsForegroundService();
    service.on('setAsForeground').listen((event) {
      service.setAsForegroundService();
    });
    service.on('setAsBackground').listen((event) {
      service.setAsBackgroundService();
    });
  }

  service.on('stopService').listen((event) {
    stompClient?.deactivate();
    service.stopSelf();
  });

  Timer.periodic(const Duration(seconds: 1), (timer) async {
    if (await Permission.locationAlways.isDenied) {
      if (service is AndroidServiceInstance) {
        if (await service.isForegroundService()) {
          await service.setForegroundNotificationInfo(
            title: "Permission Denied",
            content: "Waiting for location permission",
          );
        }
      }
      //log("Waiting for location permission");
      service.invoke('update');
    } else {
      try {
        Position position = await Geolocator.getCurrentPosition(
            desiredAccuracy: LocationAccuracy.high);

        if (service is AndroidServiceInstance) {
          if (await service.isForegroundService()) {
            await service.setForegroundNotificationInfo(
              title: "Your location",
              content: "${position.latitude},${position.longitude}",
            );
          }
        }

        //log("Background service running: ${position.latitude},${position.longitude}");
        service.invoke('update');

        // Check if we should save/send this location
        if (shouldSaveLocation(position)) {
          // Prepare location data
          final location = {
            'latitude': position.latitude,
            'longitude': position.longitude,
            'timestamp': DateTime.now().toIso8601String(),
            'userId': userId,
          };

          // Try to send via WebSocket if connected
          if (isWebSocketConnected && userId != null && userEmail != null) {
            try {
              stompClient?.send(
                destination: '/app/update-location',
                body: jsonEncode({
                  'latitude': position.latitude,
                  'longitude': position.longitude,
                  'userId': userId,
                }),
              );
              //log("Location data sent via WebSocket: $userId,${position.latitude}");

              // Update last saved position and time
              lastSavedPosition = position;
              lastSavedTime = DateTime.now();
              await saveLastSavedData(position);
            } catch (e) {
              //log("WebSocket send error, storing locally: $e");
              pendingLocations.add(location);
              await savePendingLocations();

              // Update last saved position and time
              lastSavedPosition = position;
              lastSavedTime = DateTime.now();
              await saveLastSavedData(position);

              connectWebSocket();
            }
          } else {
            //log("WebSocket not connected or user data missing - storing locally");
            pendingLocations.add(location);
            await savePendingLocations();

            // Update last saved position and time
            lastSavedPosition = position;
            lastSavedTime = DateTime.now();
            await saveLastSavedData(position);

            // Try to reconnect if not connected
            if (!isWebSocketConnected) {
              connectWebSocket();
            }
          }
        } else {
          //log("Location not saved - within 10m and less than 5 minutes since last save");
        }
      } catch (e) {
        //log("Error in background service: $e");
      }
    }
  });
}
